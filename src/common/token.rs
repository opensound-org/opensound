use aes_gcm::{
    aead::{self, Aead, AeadCore, KeyInit},
    Aes128Gcm, Key, Nonce,
};
use base64::{engine::general_purpose::URL_SAFE, DecodeError, Engine as _};
use std::{cell::OnceCell, string::FromUtf8Error};
use thiserror::Error;

#[allow(dead_code)]
const SECRET_KEY: OnceCell<Key<Aes128Gcm>> = OnceCell::new();

#[cfg(not(test))]
fn get_secret_key() -> Key<Aes128Gcm> {
    *SECRET_KEY.get_or_init(|| Aes128Gcm::generate_key(aead::OsRng))
}

#[cfg(test)]
fn get_secret_key() -> Key<Aes128Gcm> {
    [42; 16].into()
}

#[cfg(not(test))]
fn generate_nonce() -> Nonce<<Aes128Gcm as AeadCore>::NonceSize> {
    Aes128Gcm::generate_nonce(&mut aead::OsRng)
}

#[cfg(test)]
fn generate_nonce() -> Nonce<<Aes128Gcm as AeadCore>::NonceSize> {
    [21; 12].into()
}

fn bytes_to_token(bytes: &[u8]) -> String {
    let nonce = generate_nonce();
    let ciphertext = Aes128Gcm::new(&get_secret_key())
        .encrypt(&nonce, bytes)
        .unwrap();
    let mut token_bytes = Vec::new();

    token_bytes.extend(nonce);
    token_bytes.extend(ciphertext);

    URL_SAFE.encode(token_bytes)
}

/// Encrypt Gadget ID into Gadget Token
///
/// 将Gadget ID加密为Gadget Token
pub fn gadget_id_to_token(gadget_id: &str) -> String {
    bytes_to_token(gadget_id.as_bytes())
}

/// Error generated by decrypting Gadget Token
///
/// 解密Gadget Token产生的错误
///
/// Because the implementation of Display relies on the Display in the third-party Error,
/// and does not support languages other than English, this Error cannot be i18n or l10n...
///
/// 因为Display的实现依赖第三方Error中的Display，且都不支持英语以外的其它语言，因此本Error也无法i18n或l10n了……
#[derive(Error, Debug)]
pub enum DecryptError {
    #[error("base64 decode error: {0}")]
    DecodeErr(#[from] DecodeError),
    #[error("token length error")]
    TokenLenErr,
    #[error("AEAD decrypt error")]
    AeadErr(aead::Error),
    #[error("from_utf8 error: {0}")]
    FromUtf8Err(#[from] FromUtf8Error),
}

impl From<aead::Error> for DecryptError {
    fn from(value: aead::Error) -> Self {
        Self::AeadErr(value)
    }
}

/// Decrypt Gadget Token into Gadget ID
///
/// 将Gadget Token解密为Gadget ID
pub fn token_to_gadget_id(token: &str) -> Result<String, DecryptError> {
    let token_bytes = URL_SAFE.decode(token)?;

    if token_bytes.len() <= 12 {
        return Err(DecryptError::TokenLenErr);
    }

    let mut nonce: Nonce<<Aes128Gcm as AeadCore>::NonceSize> = Default::default();

    for i in 0..12 {
        nonce[i] = token_bytes[i];
    }

    Ok(String::from_utf8(
        Aes128Gcm::new(&get_secret_key()).decrypt(&nonce, &token_bytes[12..])?,
    )?)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(
            gadget_id_to_token("test"),
            "FRUVFRUVFRUVFRUVJA25ug6gR-pao86JyWi4yr-edSY="
        );
        assert_eq!(
            bytes_to_token(&vec![0, 159]),
            "FRUVFRUVFRUVFRUVUPexiuX9OrPrbaP3PMIWhPJA"
        );
        assert_eq!(
            token_to_gadget_id("FRUVFRUVFRUVFRUVJA25ug6gR-pao86JyWi4yr-edSY=").unwrap(),
            "test"
        );
        assert_eq!(
            token_to_gadget_id(&gadget_id_to_token("test")).unwrap(),
            "test"
        );

        assert_eq!(
            token_to_gadget_id("FRUVFRUVFRUVFRUVJA25ug6gR-pao86JyWi4yr-edSY/")
                .unwrap_err()
                .to_string(),
            "base64 decode error: Invalid symbol 47, offset 43."
        );
        assert_eq!(
            token_to_gadget_id("FRUV").unwrap_err().to_string(),
            "token length error"
        );
        assert_eq!(
            token_to_gadget_id("FRUVFRUVFRUVJA25ug6gR-pao86JyWi4yr-edSY=")
                .unwrap_err()
                .to_string(),
            "AEAD decrypt error"
        );
        assert_eq!(
            token_to_gadget_id("FRUVFRUVFRUVFRUVUPexiuX9OrPrbaP3PMIWhPJA")
                .unwrap_err()
                .to_string(),
            "from_utf8 error: invalid utf-8 sequence of 1 bytes from index 1"
        );
    }
}
